# -*- coding: utf-8 -*-
"""Daily Stock Notifications2

Automatically generated by Colab.

Original file is located at
"""

import datetime
import pandas as pd
import numpy as np
from scipy.stats import norm
import twstock

# 1. 資料下載處理模組
def get_stock_data(ticker, start_date):
    stock = twstock.Stock(ticker)
    stock_data = stock.fetch_from(start_date.year, start_date.month)
    df = pd.DataFrame({
        'Date': [d.date for d in stock_data],
        'Open': [d.open for d in stock_data],
        'High': [d.high for d in stock_data],
        'Low': [d.low for d in stock_data],
        'Close': [d.close for d in stock_data],
        'Volume': [d.capacity for d in stock_data]
    }).set_index('Date').sort_index()
    return df

# 2. 方法 A：Z-score 高點預測
def zscore_peak_prediction(df, window=20, threshold=0.9):
    ma = df['Close'].rolling(window).mean()
    std = df['Close'].rolling(window).std()
    z = (df['Close'] - ma) / std
    prob = norm.cdf(z)
    df['Z_Score'] = z
    df['Z_Peak_Prob'] = prob
    df['Z_Peak'] = prob > threshold
    return df

def pressure_peak_prediction(df, lookback=30, z_window=60, threshold=0.9):
    # 前高壓力（不含今日）
    df['Prev_High'] = df['High'].shift(1).rolling(window=lookback).max()

    # 偏離壓力程度
    df['Pressure_Deviation'] = (df['Close'] - df['Prev_High']) / df['Prev_High']

    # 計算壓力 Z-score 與機率
    mean_dev = df['Pressure_Deviation'].rolling(window=z_window).mean()
    std_dev = df['Pressure_Deviation'].rolling(window=z_window).std()

    df['Pressure_Z'] = (df['Pressure_Deviation'] - mean_dev) / std_dev
    df['Pressure_Prob'] = norm.cdf(df['Pressure_Z'])  # 越高代表越突破

    df['Pressure_Peak'] = df['Pressure_Prob'] > threshold
    return df

# 3. 實際高點標記（可共用）
def label_actual_peaks(df, peak_window=10):
    df['Actual_Peak'] = df['Close'] == df['Close'].rolling(peak_window, center=True).max()
    return df

# 4. 預測 vs 實際 比對
def evaluate_prediction(df, pred_col):
    return (df[pred_col] & df['Actual_Peak']).sum(), df[pred_col].sum(), df['Actual_Peak'].sum()

def run_all(tickers):
    results = []
    start_date = datetime.date.today() - datetime.timedelta(days=730)
    summary_lines = []
    for ticker in tickers:
        try:
            df = get_stock_data(ticker, start_date)

            # 方法 A: Z-score
            df = zscore_peak_prediction(df)
            # 方法 B: 壓力突破法
            df = pressure_peak_prediction(df)

            # 實際高點
            # df = label_actual_peaks(df)
            # 取最新一筆資料
            price = round(df['Close'].iloc[-1], 2)
            prob_z = round(df['Z_Peak_Prob'].iloc[-1], 3)
            prob_pressure = round(df['Pressure_Prob'].iloc[-1], 3)

            line = f"📌 {ticker}｜收盤：{price}｜Z分數機率：{prob_z}｜壓力機率：{prob_pressure}"
            summary_lines.append(line)


        except Exception as e:
            print(f"{ticker} 發生錯誤：{e}")

    # 匯總結果
    # summary = pd.DataFrame(results)
    # summary.to_csv("all_results_summary.csv", index=False)
    # files.download("all_results_summary.csv")

    # 合併成完整訊息
    today = datetime.date.today().strftime('%Y-%m-%d')
    return f"📊【高點預測總覽】{today}\n\n" + "\n\n".join(summary_lines)

import requests

tickers = ['2317', '2303', '2330']  # 自行修改代碼清單
full_message = run_all(tickers)

print(full_message)

# 用你自己的 Token 和 User ID
channel_access_token = os.getenv("LINE_CHANNEL_TOKKEN")
user_id = os.getenv("LINE_USER_ID")

headers = {
    "Content-Type": "application/json",
    "Authorization": f"Bearer {channel_access_token}"
}

payload = {
    "to": user_id,
    "messages": [{
        "type": "text",
        "text": full_message
    }]
}

response = requests.post("https://api.line.me/v2/bot/message/push", headers=headers, json=payload)

if response.status_code == 200:
    print("✅ 成功傳送訊息到 LINE")
else:
    print(f"❌ 傳送失敗：{response.text}")
